<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Dot Motion Task | Perceptual Decision Making</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <style>
        body {
            margin: 0;
        }

        /* Dual-thumb range slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid #1e293b;
            position: relative;
            z-index: 3;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid #1e293b;
            position: relative;
            z-index: 3;
        }

        input[type="range"]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }

        input[type="range"]:focus::-moz-range-thumb {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script>
        /*
        ╔═══════════════════════════════════════════════════════════════════════════╗
        ║                     FIREBASE CONFIGURATION                                ║
        ║                                                                           ║
        ║  To enable data saving and population comparison:                         ║
        ║  1. Go to https://console.firebase.google.com/                            ║
        ║  2. Create a new project (or use existing)                                ║
        ║  3. Add a web app to get your config                                      ║
        ║  4. Enable Firestore Database (start in test mode)                        ║
        ║  5. Enable Anonymous Authentication                                       ║
        ║  6. Replace the config below with your values                             ║
        ╚═══════════════════════════════════════════════════════════════════════════╝
        */

        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
        const firebaseConfig = {
            apiKey: "AIzaSyBEnZxDo-N3ZKGbA1nAD64jzPWtMviA-nw",
            authDomain: "randomdotmotiontask-778bf.firebaseapp.com",
            projectId: "randomdotmotiontask-778bf",
            storageBucket: "randomdotmotiontask-778bf.firebasestorage.app",
            messagingSenderId: "360791624435",
            appId: "1:360791624435:web:b59fb9877409e3cc7cc586",
            measurementId: "G-17EB8MY2KB"
        };

        // Check if Firebase is configured
        const isFirebaseConfigured = firebaseConfig.apiKey !== "YOUR_API_KEY";

        let db = null;
        let auth = null;

        if (isFirebaseConfigured) {
            try {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                auth = firebase.auth();
            } catch (e) {
                console.error("Firebase initialization error:", e);
            }
        }
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        /*
        ╔═══════════════════════════════════════════════════════════════════════════╗
        ║                     RANDOM DOT MOTION TASK                                ║
        ║                     WITH POPULATION COMPARISON                            ║
        ╚═══════════════════════════════════════════════════════════════════════════╝
        */

        // ═══════════════════════════════════════════════════════════════
        // HISTOGRAM COMPONENT
        // ═══════════════════════════════════════════════════════════════
        const Histogram = ({ data, userValue, label, color, unit = "" }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                if (!canvasRef.current || data.length === 0) return;

                const ctx = canvasRef.current.getContext('2d');

                // Destroy existing chart
                if (canvasRef.current.chart) {
                    canvasRef.current.chart.destroy();
                }

                // Create histogram bins
                const min = Math.min(...data);
                const max = Math.max(...data);
                const binCount = 10;
                const binWidth = (max - min) / binCount || 1;
                const bins = Array(binCount).fill(0);
                const binLabels = [];

                for (let i = 0; i < binCount; i++) {
                    const binStart = min + i * binWidth;
                    const binEnd = min + (i + 1) * binWidth;
                    binLabels.push(`${binStart.toFixed(0)}${unit}`);

                    data.forEach(val => {
                        if (val >= binStart && (val < binEnd || (i === binCount - 1 && val <= binEnd))) {
                            bins[i]++;
                        }
                    });
                }

                // Find which bin the user falls into
                const userBin = Math.min(
                    Math.floor((userValue - min) / binWidth),
                    binCount - 1
                );

                const backgroundColors = bins.map((_, i) =>
                    i === userBin ? '#f59e0b' : color
                );

                canvasRef.current.chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: binLabels,
                        datasets: [{
                            label: label,
                            data: bins,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors.map(c => c === '#f59e0b' ? '#d97706' : c.replace('0.6', '1')),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: true,
                                text: label,
                                color: '#94a3b8',
                                font: { size: 12 }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#64748b', font: { size: 9 } },
                                grid: { color: '#334155' }
                            },
                            y: {
                                ticks: { color: '#64748b' },
                                grid: { color: '#334155' },
                                title: {
                                    display: true,
                                    text: 'Count',
                                    color: '#64748b'
                                }
                            }
                        }
                    }
                });

                return () => {
                    if (canvasRef.current?.chart) {
                        canvasRef.current.chart.destroy();
                    }
                };
            }, [data, userValue, label, color, unit]);

            return (
                <div className="h-48">
                    <canvas ref={canvasRef}></canvas>
                </div>
            );
        };

        // ═══════════════════════════════════════════════════════════════
        // 2D PERFORMANCE HISTOGRAM COMPONENT
        // ═══════════════════════════════════════════════════════════════
        const PerformanceHistograms = ({ trials }) => {
            const byCoherenceCanvasRef = useRef(null);
            const rtByCoherenceCanvasRef = useRef(null);

            useEffect(() => {
                if (!trials || trials.length === 0) return;

                // Prepare data for performance by coherence
                // Dynamically find unique coherence levels from data
                const uniqueCoherences = [...new Set(trials.map(t => t.coherence))].sort((a, b) => a - b);

                // Create data grouped by coherence
                const performanceByCoherence = [];
                const rtByCoherence = [];

                uniqueCoherences.forEach(coh => {
                    const trialsAtCoh = trials.filter(t => Math.abs(t.coherence - coh) < 0.001);

                    if (trialsAtCoh.length > 0) {
                        // 1. Accuracy
                        const accuracy = (trialsAtCoh.filter(t => t.correct).length / trialsAtCoh.length) * 100;
                        performanceByCoherence.push({
                            x: coh * 100,
                            y: accuracy
                        });

                        // 2. Reaction Time (Correct trials only)
                        const correctTrials = trialsAtCoh.filter(t => t.correct);
                        if (correctTrials.length > 0) {
                            const avgRT = correctTrials.reduce((sum, t) => sum + t.rt, 0) / correctTrials.length;
                            rtByCoherence.push({
                                x: coh * 100,
                                y: avgRT
                            });
                        }
                    }
                });

                // Create performance by coherence chart
                if (byCoherenceCanvasRef.current) {
                    const ctx = byCoherenceCanvasRef.current.getContext('2d');
                    if (byCoherenceCanvasRef.current.chart) {
                        byCoherenceCanvasRef.current.chart.destroy();
                    }

                    byCoherenceCanvasRef.current.chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'Performance (%)',
                                data: performanceByCoherence,
                                backgroundColor: 'rgba(59, 130, 246, 0.2)',
                                borderColor: 'rgba(59, 130, 246, 1)',
                                borderWidth: 2,
                                pointRadius: 5,
                                pointHoverRadius: 7,
                                tension: 0.1,
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Performance by Coherence',
                                    color: '#e2e8f0',
                                    font: { size: 14 }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function (context) {
                                            return `Coherence: ${context.parsed.x.toFixed(0)}%, Accuracy: ${context.parsed.y.toFixed(1)}%`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'linear',
                                    title: {
                                        display: true,
                                        text: 'Coherence (%)',
                                        color: '#94a3b8',
                                        font: { size: 12 }
                                    },
                                    ticks: {
                                        color: '#64748b',
                                        callback: function (value) { return value.toFixed(0) + '%'; }
                                    },
                                    grid: { color: '#334155' }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Performance (Accuracy %)',
                                        color: '#94a3b8',
                                        font: { size: 12 }
                                    },
                                    min: 0,
                                    max: 100,
                                    ticks: {
                                        color: '#64748b',
                                        callback: function (value) { return value + '%'; }
                                    },
                                    grid: { color: '#334155' }
                                }
                            }
                        }
                    });
                }

                // Create RT by coherence chart
                if (rtByCoherenceCanvasRef.current) {
                    const ctx = rtByCoherenceCanvasRef.current.getContext('2d');
                    if (rtByCoherenceCanvasRef.current.chart) {
                        rtByCoherenceCanvasRef.current.chart.destroy();
                    }

                    rtByCoherenceCanvasRef.current.chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'Reaction Time (ms)',
                                data: rtByCoherence,
                                backgroundColor: 'rgba(34, 197, 94, 0.2)',
                                borderColor: 'rgba(34, 197, 94, 1)',
                                borderWidth: 2,
                                pointRadius: 5,
                                pointHoverRadius: 7,
                                tension: 0.1,
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Reaction Time by Coherence',
                                    color: '#e2e8f0',
                                    font: { size: 14 }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function (context) {
                                            return `Coherence: ${context.parsed.x.toFixed(0)}%, RT: ${context.parsed.y.toFixed(0)}ms`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'linear',
                                    title: {
                                        display: true,
                                        text: 'Coherence (%)',
                                        color: '#94a3b8',
                                        font: { size: 12 }
                                    },
                                    ticks: {
                                        color: '#64748b',
                                        callback: function (value) { return value.toFixed(0) + '%'; }
                                    },
                                    grid: { color: '#334155' }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Reaction Time (ms)',
                                        color: '#94a3b8',
                                        font: { size: 12 }
                                    },
                                    min: 0,
                                    // Max will auto-scale, which is good for RT
                                    ticks: {
                                        color: '#64748b',
                                        callback: function (value) { return value + 'ms'; }
                                    },
                                    grid: { color: '#334155' }
                                }
                            }
                        }
                    });
                }

                return () => {
                    if (byCoherenceCanvasRef.current?.chart) {
                        byCoherenceCanvasRef.current.chart.destroy();
                    }
                    if (rtByCoherenceCanvasRef.current?.chart) {
                        rtByCoherenceCanvasRef.current.chart.destroy();
                    }
                };
            }, [trials]);

            return (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div className="bg-slate-900 rounded-lg p-3">
                        <div className="h-64">
                            <canvas ref={byCoherenceCanvasRef}></canvas>
                        </div>
                    </div>
                    <div className="bg-slate-900 rounded-lg p-3">
                        <div className="h-64">
                            <canvas ref={rtByCoherenceCanvasRef}></canvas>
                        </div>
                    </div>
                </div>
            );
        };

        // ═══════════════════════════════════════════════════════════════
        // PERCENTILE CALCULATOR
        // ═══════════════════════════════════════════════════════════════
        const calculatePercentile = (value, data) => {
            if (data.length === 0) return 50;
            const sorted = [...data].sort((a, b) => a - b);
            const index = sorted.findIndex(v => v >= value);
            if (index === -1) return 100;
            return Math.round((index / sorted.length) * 100);
        };

        // ═══════════════════════════════════════════════════════════════
        // MAIN COMPONENT
        // ═══════════════════════════════════════════════════════════════
        const DotMotionTask = () => {
            const canvasRef = useRef(null);

            // Game state
            const [gameState, setGameState] = useState('intro');
            const [participantId, setParticipantId] = useState(null);
            const [participantName, setParticipantName] = useState('');

            // Parameters
            const [coherence, setCoherence] = useState(0.3);
            const [numDots, setNumDots] = useState(100);
            const [stimulusDuration, setStimulusDuration] = useState(1000);

            // User-configurable ranges for randomization
            // Fixed parameters for this version
            // Coherence: 0, 5, 10%
            // Duration: Until response

            // Trial data
            const [trials, setTrials] = useState([]);
            const [trialCount, setTrialCount] = useState(0);
            const [totalTrials, setTotalTrials] = useState(20);
            const [feedback, setFeedback] = useState(null);
            const [stimulusStartTime, setStimulusStartTime] = useState(null);

            // Trial-specific parameters (generated once for all trials)
            const [trialCoherences, setTrialCoherences] = useState([]);
            const [trialDurations, setTrialDurations] = useState([]);

            // Population data
            const [populationData, setPopulationData] = useState([]);
            const [isLoadingPopulation, setIsLoadingPopulation] = useState(false);
            const [dataSaved, setDataSaved] = useState(false);

            // Firebase status
            const [firebaseStatus, setFirebaseStatus] = useState(
                isFirebaseConfigured ? 'connecting' : 'not_configured'
            );

            // Display constants
            const CANVAS_SIZE = 300;
            const DOT_RADIUS = 2;
            const DOT_SPEED = 3;
            const APERTURE_RADIUS = 120;

            // Refs
            const dotsRef = useRef([]);
            const directionRef = useRef(1);
            const animationRef = useRef(null);

            // Initialize trial-specific parameters
            useEffect(() => {
                const coherences = [];
                const durations = [];
                const allowedCoherences = [0.02, 0.05, 0.08];

                for (let i = 0; i < totalTrials; i++) {
                    // Randomly select from discrete coherence levels
                    const selectedCoherence = allowedCoherences[Math.floor(Math.random() * allowedCoherences.length)];
                    coherences.push(selectedCoherence);

                    // Duration is determined by user response time, so we initialize as null or 0
                    durations.push(0);
                }
                setTrialCoherences(coherences);
                setTrialDurations(durations);
            }, [totalTrials]);

            // ═══════════════════════════════════════════════════════════════
            // FIREBASE AUTHENTICATION
            // ═══════════════════════════════════════════════════════════════
            useEffect(() => {
                console.log('Firebase initialization check...');
                console.log('isFirebaseConfigured:', isFirebaseConfigured);
                console.log('auth:', !!auth);
                console.log('db:', !!db);

                if (!isFirebaseConfigured || !auth) {
                    console.log('Firebase not configured or auth not available');
                    setFirebaseStatus('not_configured');
                    return;
                }

                console.log('Attempting anonymous authentication...');
                auth.signInAnonymously()
                    .then((result) => {
                        console.log('✅ Successfully authenticated with Firebase');
                        console.log('User ID:', result.user.uid);
                        setParticipantId(result.user.uid);
                        setFirebaseStatus('connected');
                    })
                    .catch((error) => {
                        console.error("❌ Firebase auth error:", error);
                        console.error("Error code:", error.code);
                        console.error("Error message:", error.message);
                        setFirebaseStatus('error');
                    });
            }, []);

            // ═══════════════════════════════════════════════════════════════
            // LOAD POPULATION DATA
            // ═══════════════════════════════════════════════════════════════
            const loadPopulationData = async () => {
                if (!db || firebaseStatus !== 'connected') {
                    console.log('Cannot load population data: Firebase not connected. Status:', firebaseStatus);
                    return;
                }

                console.log('Loading population data from Firebase...');
                setIsLoadingPopulation(true);
                try {
                    const snapshot = await db.collection('dot_motion_results')
                        .orderBy('timestamp', 'desc')
                        .limit(500)
                        .get();

                    const data = snapshot.docs.map(doc => doc.data());
                    console.log('Successfully loaded', data.length, 'results from Firebase');
                    setPopulationData(data);
                } catch (error) {
                    console.error("Error loading population data:", error);
                    console.error("Error message:", error.message);
                    if (error.code) console.error("Error code:", error.code);
                }
                setIsLoadingPopulation(false);
            };

            // ═══════════════════════════════════════════════════════════════
            // SAVE RESULTS TO FIREBASE
            // ═══════════════════════════════════════════════════════════════
            const saveResults = async (accuracy, meanRT, correctRT) => {
                if (!db || firebaseStatus !== 'connected') {
                    console.log('Cannot save: Firebase not connected. Status:', firebaseStatus);
                    return;
                }

                console.log('Attempting to save results to Firebase...');

                try {
                    const resultData = {
                        participantId,
                        participantName: participantName || 'Anonymous',
                        // Save summary statistics
                        accuracy,
                        meanRT,
                        correctRT,
                        totalTrials,
                        numDots,
                        // Save fixed parameter config
                        coherenceConfig: "Discrete: 2, 5, 8%",
                        durationConfig: "Until response",
                        // Save full trial-by-trial data with individual parameters
                        // Save full trial-by-trial data with individual parameters
                        trials,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        userAgent: navigator.userAgent
                    };

                    console.log('Saving data:', resultData);

                    const docRef = await db.collection('dot_motion_results').add(resultData);
                    console.log('Successfully saved with ID:', docRef.id);

                    setDataSaved(true);
                    // Reload population data to include this result
                    await loadPopulationData();
                } catch (error) {
                    console.error("Error saving results:", error);
                    console.error("Error details:", error.message);
                    alert('Failed to save results: ' + error.message);
                }
            };

            // ═══════════════════════════════════════════════════════════════
            // DOT MOTION LOGIC
            // ═══════════════════════════════════════════════════════════════
            const initializeDots = useCallback((trialCoherence = coherence) => {
                const dots = [];
                for (let i = 0; i < numDots; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * APERTURE_RADIUS;
                    dots.push({
                        x: CANVAS_SIZE / 2 + Math.cos(angle) * r,
                        y: CANVAS_SIZE / 2 + Math.sin(angle) * r,
                        isSignal: Math.random() < trialCoherence
                    });
                }
                dotsRef.current = dots;
            }, [numDots, coherence]);

            const updateDots = useCallback(() => {
                dotsRef.current = dotsRef.current.map(dot => {
                    let newX, newY;

                    if (dot.isSignal) {
                        newX = dot.x + DOT_SPEED * directionRef.current;
                        newY = dot.y;
                    } else {
                        const randomAngle = Math.random() * Math.PI * 2;
                        newX = dot.x + Math.cos(randomAngle) * DOT_SPEED;
                        newY = dot.y + Math.sin(randomAngle) * DOT_SPEED;
                    }

                    const dx = newX - CANVAS_SIZE / 2;
                    const dy = newY - CANVAS_SIZE / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > APERTURE_RADIUS) {
                        const angle = Math.atan2(dy, dx) + Math.PI;
                        newX = CANVAS_SIZE / 2 + Math.cos(angle) * APERTURE_RADIUS * 0.9;
                        newY = CANVAS_SIZE / 2 + Math.sin(angle) * APERTURE_RADIUS * 0.9;
                    }

                    return { ...dot, x: newX, y: newY };
                });
            }, []);

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

                ctx.strokeStyle = '#4a4a6a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, APERTURE_RADIUS, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(CANVAS_SIZE / 2 - 10, CANVAS_SIZE / 2);
                ctx.lineTo(CANVAS_SIZE / 2 + 10, CANVAS_SIZE / 2);
                ctx.moveTo(CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 10);
                ctx.lineTo(CANVAS_SIZE / 2, CANVAS_SIZE / 2 + 10);
                ctx.stroke();

                if (gameState === 'stimulus') {
                    ctx.fillStyle = '#ffffff';
                    dotsRef.current.forEach(dot => {
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            }, [gameState]);

            useEffect(() => {
                if (gameState === 'stimulus') {
                    const animate = () => {
                        updateDots();
                        draw();
                        animationRef.current = requestAnimationFrame(animate);
                    };
                    animate();

                    return () => {
                        if (animationRef.current) {
                            cancelAnimationFrame(animationRef.current);
                        }
                    };
                } else {
                    draw();
                }
            }, [gameState, draw, updateDots]);

            const startTrial = useCallback(() => {
                if (trialCoherences.length === 0 || trialDurations.length === 0) return;

                directionRef.current = Math.random() < 0.5 ? -1 : 1;
                const trialCoherence = trialCoherences[trialCount];
                const trialDuration = trialDurations[trialCount];

                initializeDots(trialCoherence);
                setGameState('stimulus');
                setStimulusStartTime(Date.now());

                // Stimulus stays on until response (no timeout)
            }, [initializeDots, trialCount, trialCoherences, trialDurations]);

            const handleResponse = useCallback((response) => {
                if (gameState !== 'stimulus' && gameState !== 'ready') return;
                if (stimulusStartTime === null) return;

                const rt = Date.now() - stimulusStartTime;
                const correct = (response === 'left' && directionRef.current === -1) ||
                    (response === 'right' && directionRef.current === 1);

                const currentCoherence = trialCoherences[trialCount];
                const trialData = {
                    trialNum: trialCount + 1,
                    direction: directionRef.current === 1 ? 'right' : 'left',
                    response,
                    correct,
                    rt,
                    coherence: currentCoherence !== undefined ? currentCoherence : coherence,
                    stimulusDuration: rt // Duration is the reaction time
                };

                setTrials(prev => [...prev, trialData]);
                setFeedback(correct ? 'Correct!' : 'Incorrect');
                setGameState('feedback');

                setTimeout(() => {
                    if (trialCount + 1 >= totalTrials) {
                        setGameState('results');
                    } else {
                        setTrialCount(prev => prev + 1);
                        setFeedback(null);
                        // Small delay before next trial is ready
                        setTimeout(() => setGameState('ready'), 200);
                    }
                }, 800);
            }, [gameState, stimulusStartTime, trialCount, totalTrials, coherence]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowLeft') {
                        handleResponse('left');
                    } else if (e.key === 'ArrowRight') {
                        handleResponse('right');
                    } else if (e.key === ' ' && gameState === 'ready') {
                        e.preventDefault();
                        startTrial();
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleResponse, startTrial, gameState]);

            // ═══════════════════════════════════════════════════════════════
            // RESULTS CALCULATION
            // ═══════════════════════════════════════════════════════════════
            const getResults = useCallback(() => {
                if (trials.length === 0) return { accuracy: 0, meanRT: 0, correctRT: 0 };
                const accuracy = trials.filter(t => t.correct).length / trials.length;
                const meanRT = trials.reduce((sum, t) => sum + t.rt, 0) / trials.length;
                const correctTrials = trials.filter(t => t.correct);
                const correctRT = correctTrials.length > 0
                    ? correctTrials.reduce((sum, t) => sum + t.rt, 0) / correctTrials.length
                    : 0;
                return { accuracy, meanRT, correctRT };
            }, [trials]);

            // Save and load when reaching results
            useEffect(() => {
                if (gameState === 'results' && !dataSaved) {
                    const { accuracy, meanRT, correctRT } = getResults();
                    saveResults(accuracy, meanRT, correctRT);
                    loadPopulationData();
                }
            }, [gameState, dataSaved, getResults]);

            const resetGame = () => {
                setTrials([]);
                setTrialCount(0);
                setFeedback(null);
                setDataSaved(false);
                setGameState('intro');
            };

            // Population statistics
            const populationAccuracies = populationData.map(d => d.accuracy * 100);
            const populationRTs = populationData.filter(d => d.correctRT > 0).map(d => d.correctRT);
            const myResults = getResults();

            // ═══════════════════════════════════════════════════════════════
            // RENDER
            // ═══════════════════════════════════════════════════════════════
            return (
                <div className="min-h-screen bg-slate-900 text-white p-6">
                    <div className="max-w-3xl mx-auto">
                        <h1 className="text-2xl font-bold text-center mb-2">
                            Random Dot Motion Task
                        </h1>
                        <p className="text-slate-400 text-center text-sm mb-2">
                            A classic perceptual decision-making paradigm
                        </p>

                        {/* Firebase Status */}
                        <div className="text-center mb-4">
                            {firebaseStatus === 'connected' && (
                                <span className="text-xs bg-green-900 text-green-300 px-2 py-1 rounded">
                                    ● Data saving enabled
                                </span>
                            )}
                            {firebaseStatus === 'not_configured' && (
                                <span className="text-xs bg-yellow-900 text-yellow-300 px-2 py-1 rounded">
                                    ○ Demo mode (data not saved)
                                </span>
                            )}
                            {firebaseStatus === 'error' && (
                                <span className="text-xs bg-red-900 text-red-300 px-2 py-1 rounded">
                                    ✕ Connection error
                                </span>
                            )}
                        </div>

                        {/* ─────────────────────────────────────────────────────── */}
                        {/* INTRO SCREEN                                            */}
                        {/* ─────────────────────────────────────────────────────── */}
                        {gameState === 'intro' && (
                            <div className="bg-slate-800 rounded-lg p-6 mb-6">
                                <h2 className="text-lg font-semibold mb-4">Instructions</h2>
                                <p className="text-slate-300 mb-4">
                                    You'll see a cloud of moving dots. Some dots move coherently
                                    LEFT or RIGHT, while others move randomly. Your job is to
                                    decide which direction the coherent dots are moving.
                                </p>
                                <ul className="text-slate-300 space-y-2 mb-6">
                                    <li>• Press <span className="bg-slate-700 px-2 py-1 rounded font-mono">SPACE</span> or tap the button to start each trial</li>
                                    <li>• Press <span className="bg-slate-700 px-2 py-1 rounded font-mono">←</span>/<span className="bg-slate-700 px-2 py-1 rounded font-mono">→</span> or tap LEFT/RIGHT buttons to respond</li>
                                    <li>• Respond as quickly and accurately as possible</li>
                                </ul>

                                {/* Name input */}
                                {firebaseStatus === 'connected' && (
                                    <div className="mb-4">
                                        <label className="block text-sm text-slate-400 mb-1">
                                            Your name (optional, for leaderboard):
                                        </label>
                                        <input
                                            type="text"
                                            value={participantName}
                                            onChange={(e) => setParticipantName(e.target.value)}
                                            placeholder="Anonymous"
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white placeholder-slate-500"
                                        />
                                    </div>
                                )}

                                <div className="border-t border-slate-700 pt-4 mt-4">
                                    <h3 className="text-sm font-semibold text-slate-400 mb-3">
                                        PARAMETERS
                                    </h3>
                                    <div className="grid grid-cols-1 gap-4">
                                        <div>
                                            <label className="block text-sm font-medium text-slate-300 mb-3">
                                                Number of Trials: <span className="text-blue-400 font-bold">{totalTrials}</span>
                                            </label>
                                            <input
                                                type="range"
                                                min="5"
                                                max="50"
                                                step="5"
                                                value={totalTrials}
                                                onChange={(e) => setTotalTrials(parseInt(e.target.value))}
                                                className="w-full accent-blue-500"
                                            />
                                            <div className="flex justify-between text-xs font-semibold text-slate-300 mt-2">
                                                <span className="bg-slate-700 px-2 py-0.5 rounded">5</span>
                                                <span className="bg-slate-700 px-2 py-0.5 rounded">50</span>
                                            </div>
                                        </div>
                                        <div>
                                            <p className="text-sm text-slate-400 mb-2">
                                                <span className="font-semibold text-slate-300">Coherence Levels:</span> 2%, 5%, 8%
                                            </p>
                                            <p className="text-sm text-slate-400">
                                                <span className="font-semibold text-slate-300">Duration:</span> Until response
                                            </p>
                                        </div>
                                    </div>
                                </div>

                                <button
                                    onClick={() => setGameState('ready')}
                                    className="w-full mt-6 bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-semibold transition"
                                >
                                    Start Experiment
                                </button>
                            </div>
                        )}

                        {/* ─────────────────────────────────────────────────────── */}
                        {/* TRIAL SCREEN                                            */}
                        {/* ─────────────────────────────────────────────────────── */}
                        {(gameState === 'ready' || gameState === 'stimulus' || gameState === 'feedback') && (
                            <div className="flex flex-col items-center">
                                <div className="mb-4 text-sm text-slate-400 text-center">
                                    Trial {trialCount + 1} of {totalTrials} |
                                    Coherence: {trialCoherences.length > 0 ? (trialCoherences[trialCount] * 100).toFixed(0) : (coherence * 100).toFixed(0)}%
                                </div>

                                <canvas
                                    ref={canvasRef}
                                    width={CANVAS_SIZE}
                                    height={CANVAS_SIZE}
                                    className="rounded-lg mb-4 max-w-full h-auto"
                                />

                                {gameState === 'ready' && !feedback && (
                                    <div className="mb-4 flex flex-col items-center gap-2">
                                        <p className="text-slate-400 text-sm text-center">Press SPACE or tap below to start trial</p>
                                        <button
                                            onClick={startTrial}
                                            className="bg-blue-600 hover:bg-blue-700 active:bg-blue-800 px-8 py-4 rounded-lg font-semibold text-lg transition touch-manipulation"
                                        >
                                            ▶ Start Trial
                                        </button>
                                    </div>
                                )}

                                {feedback && (
                                    <p className={`text-lg font-bold mb-4 ${feedback === 'Correct!' ? 'text-green-400' : 'text-red-400'
                                        }`}>
                                        {feedback}
                                    </p>
                                )}

                                <div className="flex flex-col sm:flex-row gap-3 w-full max-w-md px-4">
                                    <button
                                        onClick={() => handleResponse('left')}
                                        disabled={gameState === 'feedback'}
                                        className="flex-1 bg-slate-700 hover:bg-slate-600 active:bg-slate-500 disabled:opacity-50 disabled:cursor-not-allowed px-6 py-4 rounded-lg font-bold text-lg transition touch-manipulation"
                                    >
                                        ← LEFT
                                    </button>
                                    <button
                                        onClick={() => handleResponse('right')}
                                        disabled={gameState === 'feedback'}
                                        className="flex-1 bg-slate-700 hover:bg-slate-600 active:bg-slate-500 disabled:opacity-50 disabled:cursor-not-allowed px-6 py-4 rounded-lg font-bold text-lg transition touch-manipulation"
                                    >
                                        RIGHT →
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* ─────────────────────────────────────────────────────── */}
                        {/* RESULTS SCREEN                                          */}
                        {/* ─────────────────────────────────────────────────────── */}
                        {gameState === 'results' && (
                            <div className="bg-slate-800 rounded-lg p-6">
                                <h2 className="text-xl font-bold mb-6 text-center">Experiment Results</h2>

                                {firebaseStatus !== 'connected' && (
                                    <div className="bg-amber-900/30 border border-amber-600 rounded-lg p-4 mb-6 text-center">
                                        <p className="text-amber-300 font-semibold mb-2">
                                            ⚠️ Firebase Status: {firebaseStatus}
                                        </p>
                                        <p className="text-sm text-slate-300">
                                            {firebaseStatus === 'not_configured' && 'Firebase not configured. Data will not be saved.'}
                                            {firebaseStatus === 'error' && 'Firebase connection error. Check console for details.'}
                                            {firebaseStatus === 'connecting' && 'Connecting to Firebase...'}
                                        </p>
                                        {firebaseStatus !== 'connecting' && (
                                            <p className="text-xs text-slate-400 mt-2">
                                                Open browser console (F12) for more details
                                            </p>
                                        )}
                                    </div>
                                )}

                                {/* Individual Performance Summary */}
                                <div className="mb-6">
                                    <h3 className="text-lg font-semibold mb-4 text-center">
                                        🎯 Your Performance Summary
                                    </h3>
                                    <div className="bg-slate-700 rounded-lg p-4">
                                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                                            <div className="text-center">
                                                <div className="text-4xl font-bold text-blue-400 mb-2">
                                                    {(myResults.accuracy * 100).toFixed(1)}%
                                                </div>
                                                <div className="text-sm text-slate-400">Overall Accuracy</div>
                                                <div className="text-xs text-slate-500 mt-1">
                                                    {trials.filter(t => t.correct).length}/{trials.length} correct
                                                </div>
                                            </div>
                                            <div className="text-center">
                                                <div className="text-4xl font-bold text-green-400 mb-2">
                                                    {myResults.correctRT.toFixed(0)}ms
                                                </div>
                                                <div className="text-sm text-slate-400">Mean Correct RT</div>
                                                <div className="text-xs text-slate-500 mt-1">
                                                    Range: {Math.min(...trials.filter(t => t.correct).map(t => t.rt)).toFixed(0)}-{Math.max(...trials.filter(t => t.correct).map(t => t.rt)).toFixed(0)}ms
                                                </div>
                                            </div>
                                            <div className="text-center">
                                                <div className="text-4xl font-bold text-yellow-400 mb-2">
                                                    {totalTrials}
                                                </div>
                                                <div className="text-sm text-slate-400">Trials Completed</div>
                                                <div className="text-xs text-slate-500 mt-1">
                                                    Coherence: {((trialCoherences.reduce((a, b) => a + b, 0) / trialCoherences.length) * 100).toFixed(1)}% (Avg)
                                                </div>
                                                <div className="text-xs text-slate-500">
                                                    Duration: Response Dependent
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Performance Analysis Histograms */}
                                <div className="mb-6">
                                    <h3 className="text-lg font-semibold mb-4 text-center">
                                        📈 Performance Analysis
                                    </h3>
                                    <PerformanceHistograms trials={trials} />
                                    <div className="text-center text-xs text-slate-400">
                                        Line charts show how your accuracy changes with stimulus coherence and duration.
                                    </div>
                                </div>

                                {/* Population Comparison */}
                                {populationData.length > 1 && (
                                    <div className="mb-6">
                                        <div className="flex items-center justify-between mb-4">
                                            <h3 className="text-lg font-semibold text-center flex-1">
                                                📊 Population Performance
                                            </h3>
                                            <button
                                                onClick={loadPopulationData}
                                                disabled={isLoadingPopulation}
                                                className="bg-blue-600 hover:bg-blue-700 disabled:bg-slate-600 px-3 py-1 rounded text-sm transition"
                                                title="Refresh population data"
                                            >
                                                {isLoadingPopulation ? '⟳' : '🔄'} Refresh
                                            </button>
                                        </div>
                                        <div className="text-center text-sm text-slate-400 mb-4">
                                            {populationData.length} users • {populationData.reduce((sum, d) => sum + (d.totalTrials || 0), 0).toLocaleString()} total trials
                                        </div>

                                        {/* Population Summary Stats */}
                                        <div className="bg-slate-900 rounded-lg p-4 mb-4">
                                            <h4 className="font-semibold mb-3 text-center text-slate-300">Aggregate Statistics</h4>
                                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                                                <div>
                                                    <div className="text-xl font-bold text-blue-400">
                                                        {(populationAccuracies.reduce((a, b) => a + b, 0) / populationAccuracies.length).toFixed(1)}%
                                                    </div>
                                                    <div className="text-xs text-slate-400">Mean Accuracy</div>
                                                </div>
                                                <div>
                                                    <div className="text-xl font-bold text-green-400">
                                                        {(populationRTs.reduce((a, b) => a + b, 0) / populationRTs.length).toFixed(0)}ms
                                                    </div>
                                                    <div className="text-xs text-slate-400">Mean RT</div>
                                                </div>
                                                <div>
                                                    <div className="text-xl font-bold text-purple-400">
                                                        {Math.max(...populationAccuracies).toFixed(0)}%
                                                    </div>
                                                    <div className="text-xs text-slate-400">Best Accuracy</div>
                                                </div>
                                                <div>
                                                    <div className="text-xl font-bold text-orange-400">
                                                        {Math.min(...populationRTs).toFixed(0)}ms
                                                    </div>
                                                    <div className="text-xs text-slate-400">Fastest RT</div>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Your Performance vs Population */}
                                        <div className="bg-slate-900 rounded-lg p-4 mb-4">
                                            <h4 className="font-semibold mb-3 text-center text-slate-300">Your Performance Ranking</h4>
                                            <div className="grid grid-cols-2 gap-4">
                                                <div className="text-center">
                                                    <div className="text-3xl font-bold text-blue-400 mb-1">
                                                        {calculatePercentile(myResults.accuracy * 100, populationAccuracies)}th
                                                    </div>
                                                    <div className="text-sm text-slate-400 mb-2">Accuracy Percentile</div>
                                                    <div className="text-xs text-slate-500">
                                                        You scored better than {calculatePercentile(myResults.accuracy * 100, populationAccuracies)}% of users
                                                    </div>
                                                </div>
                                                <div className="text-center">
                                                    <div className="text-3xl font-bold text-green-400 mb-1">
                                                        {100 - calculatePercentile(myResults.correctRT, populationRTs)}th
                                                    </div>
                                                    <div className="text-sm text-slate-400 mb-2">Speed Percentile</div>
                                                    <div className="text-xs text-slate-500">
                                                        You were faster than {100 - calculatePercentile(myResults.correctRT, populationRTs)}% of users
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Population Average Performance */}
                                        <div className="mb-6">
                                            <h4 className="font-semibold mb-3 text-center text-slate-300">Population Average Performance</h4>
                                            <PerformanceHistograms
                                                trials={populationData.flatMap(d => d.trials || [])}
                                            />
                                            <div className="text-center text-xs text-slate-400">
                                                Aggregated data from all users. Note: Coherence levels may vary across experiments.
                                            </div>
                                        </div>

                                        {/* Histograms */}
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div className="bg-slate-900 rounded-lg p-3">
                                                <Histogram
                                                    data={populationAccuracies}
                                                    userValue={myResults.accuracy * 100}
                                                    label="Accuracy Distribution (%)"
                                                    color="rgba(59, 130, 246, 0.6)"
                                                    unit="%"
                                                />
                                                <div className="text-center text-xs text-amber-400 mt-2">
                                                    ■ Your score highlighted in orange
                                                </div>
                                            </div>
                                            <div className="bg-slate-900 rounded-lg p-3">
                                                <Histogram
                                                    data={populationRTs}
                                                    userValue={myResults.correctRT}
                                                    label="Reaction Time Distribution (ms)"
                                                    color="rgba(34, 197, 94, 0.6)"
                                                    unit="ms"
                                                />
                                                <div className="text-center text-xs text-amber-400 mt-2">
                                                    ■ Your score highlighted in orange
                                                </div>
                                            </div>
                                        </div>

                                        {/* Population stats */}
                                        <div className="mt-4 text-center text-sm text-slate-400">
                                            Population avg: {(populationAccuracies.reduce((a, b) => a + b, 0) / populationAccuracies.length).toFixed(0)}% accuracy, {" "}
                                            {(populationRTs.reduce((a, b) => a + b, 0) / populationRTs.length).toFixed(0)}ms RT
                                        </div>
                                    </div>
                                )}

                                {populationData.length <= 1 && firebaseStatus === 'connected' && (
                                    <div className="bg-slate-900 rounded-lg p-4 mb-6">
                                        <div className="flex items-center justify-between mb-2">
                                            <p className="text-slate-400 flex-1 text-center">
                                                {isLoadingPopulation ? (
                                                    "Loading population data..."
                                                ) : (
                                                    "You're among the first! Population comparison will appear as more people complete the task."
                                                )}
                                            </p>
                                            <button
                                                onClick={loadPopulationData}
                                                disabled={isLoadingPopulation}
                                                className="bg-blue-600 hover:bg-blue-700 disabled:bg-slate-600 px-3 py-1 rounded text-sm transition ml-3"
                                                title="Refresh population data"
                                            >
                                                {isLoadingPopulation ? '⟳' : '🔄'}
                                            </button>
                                        </div>
                                        {populationData.length === 1 && (
                                            <div className="text-center text-xs text-slate-500 mt-2">
                                                {populationData.reduce((sum, d) => sum + (d.totalTrials || 0), 0)} trials completed
                                            </div>
                                        )}
                                    </div>
                                )}

                                {/* Trial data */}
                                <div className="bg-slate-700 rounded-lg p-4 mb-6">
                                    <h3 className="font-semibold mb-2">Trial-by-Trial Data</h3>
                                    <div className="text-xs font-mono text-slate-400 max-h-32 overflow-y-auto">
                                        <div className="grid grid-cols-7 gap-1 mb-1 text-slate-500 border-b border-slate-600 pb-1">
                                            <span>Trial</span>
                                            <span>Dir</span>
                                            <span>Resp</span>
                                            <span>Correct</span>
                                            <span>RT</span>
                                            <span>Coh%</span>
                                            <span>Dur</span>
                                        </div>
                                        {trials.map((t, i) => (
                                            <div key={i} className="grid grid-cols-7 gap-1 py-0.5">
                                                <span>{t.trialNum}</span>
                                                <span>{t.direction}</span>
                                                <span>{t.response}</span>
                                                <span className={t.correct ? 'text-green-400' : 'text-red-400'}>
                                                    {t.correct ? '✓' : '✗'}
                                                </span>
                                                <span>{t.rt}ms</span>
                                                <span>{(t.coherence * 100).toFixed(0)}%</span>
                                                <span>{t.stimulusDuration}ms</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {/* Data saved indicator */}
                                {dataSaved && (
                                    <div className="text-center text-sm text-green-400 mb-4">
                                        ✓ Your results have been saved
                                    </div>
                                )}

                                <button
                                    onClick={resetGame}
                                    className="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-semibold transition"
                                >
                                    Try Again
                                </button>
                            </div>
                        )}

                        {/* Footer */}
                        <div className="mt-8 text-center text-xs text-slate-500">
                            <p>Based on the random dot kinematogram paradigm</p>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DotMotionTask />);
    </script>
</body>

</html>