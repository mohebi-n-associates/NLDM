<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Dot Motion Task | Perceptual Decision Making</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    
    <style>
        body { margin: 0; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script>
        /*
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘                     FIREBASE CONFIGURATION                                â•‘
        â•‘                                                                           â•‘
        â•‘  To enable data saving and population comparison:                         â•‘
        â•‘  1. Go to https://console.firebase.google.com/                            â•‘
        â•‘  2. Create a new project (or use existing)                                â•‘
        â•‘  3. Add a web app to get your config                                      â•‘
        â•‘  4. Enable Firestore Database (start in test mode)                        â•‘
        â•‘  5. Enable Anonymous Authentication                                       â•‘
        â•‘  6. Replace the config below with your values                             â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
        const firebaseConfig = {
          apiKey: "AIzaSyBEnZxDo-N3ZKGbA1nAD64jzPWtMviA-nw",
          authDomain: "randomdotmotiontask-778bf.firebaseapp.com",
          projectId: "randomdotmotiontask-778bf",
          storageBucket: "randomdotmotiontask-778bf.firebasestorage.app",
          messagingSenderId: "360791624435",
          appId: "1:360791624435:web:b59fb9877409e3cc7cc586",
          measurementId: "G-17EB8MY2KB"
        };
        
        // Check if Firebase is configured
        const isFirebaseConfigured = firebaseConfig.apiKey !== "YOUR_API_KEY";
        
        let db = null;
        let auth = null;
        
        if (isFirebaseConfigured) {
            try {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                auth = firebase.auth();
            } catch (e) {
                console.error("Firebase initialization error:", e);
            }
        }
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        /*
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘                     RANDOM DOT MOTION TASK                                â•‘
        â•‘                     WITH POPULATION COMPARISON                            â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HISTOGRAM COMPONENT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const Histogram = ({ data, userValue, label, color, unit = "" }) => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current || data.length === 0) return;
                
                const ctx = canvasRef.current.getContext('2d');
                
                // Destroy existing chart
                if (canvasRef.current.chart) {
                    canvasRef.current.chart.destroy();
                }
                
                // Create histogram bins
                const min = Math.min(...data);
                const max = Math.max(...data);
                const binCount = 10;
                const binWidth = (max - min) / binCount || 1;
                const bins = Array(binCount).fill(0);
                const binLabels = [];
                
                for (let i = 0; i < binCount; i++) {
                    const binStart = min + i * binWidth;
                    const binEnd = min + (i + 1) * binWidth;
                    binLabels.push(`${binStart.toFixed(0)}${unit}`);
                    
                    data.forEach(val => {
                        if (val >= binStart && (val < binEnd || (i === binCount - 1 && val <= binEnd))) {
                            bins[i]++;
                        }
                    });
                }
                
                // Find which bin the user falls into
                const userBin = Math.min(
                    Math.floor((userValue - min) / binWidth),
                    binCount - 1
                );
                
                const backgroundColors = bins.map((_, i) => 
                    i === userBin ? '#f59e0b' : color
                );
                
                canvasRef.current.chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: binLabels,
                        datasets: [{
                            label: label,
                            data: bins,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors.map(c => c === '#f59e0b' ? '#d97706' : c.replace('0.6', '1')),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: true,
                                text: label,
                                color: '#94a3b8',
                                font: { size: 12 }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#64748b', font: { size: 9 } },
                                grid: { color: '#334155' }
                            },
                            y: {
                                ticks: { color: '#64748b' },
                                grid: { color: '#334155' },
                                title: {
                                    display: true,
                                    text: 'Count',
                                    color: '#64748b'
                                }
                            }
                        }
                    }
                });
                
                return () => {
                    if (canvasRef.current?.chart) {
                        canvasRef.current.chart.destroy();
                    }
                };
            }, [data, userValue, label, color, unit]);
            
            return (
                <div className="h-48">
                    <canvas ref={canvasRef}></canvas>
                </div>
            );
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PERCENTILE CALCULATOR
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const calculatePercentile = (value, data) => {
            if (data.length === 0) return 50;
            const sorted = [...data].sort((a, b) => a - b);
            const index = sorted.findIndex(v => v >= value);
            if (index === -1) return 100;
            return Math.round((index / sorted.length) * 100);
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MAIN COMPONENT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const DotMotionTask = () => {
            const canvasRef = useRef(null);
            
            // Game state
            const [gameState, setGameState] = useState('intro');
            const [participantId, setParticipantId] = useState(null);
            const [participantName, setParticipantName] = useState('');
            
            // Parameters
            const [coherence, setCoherence] = useState(0.3);
            const [numDots, setNumDots] = useState(100);
            const [stimulusDuration, setStimulusDuration] = useState(1000);
            
            // Trial data
            const [trials, setTrials] = useState([]);
            const [trialCount, setTrialCount] = useState(0);
            const [totalTrials] = useState(10);
            const [feedback, setFeedback] = useState(null);
            const [stimulusStartTime, setStimulusStartTime] = useState(null);
            
            // Population data
            const [populationData, setPopulationData] = useState([]);
            const [isLoadingPopulation, setIsLoadingPopulation] = useState(false);
            const [dataSaved, setDataSaved] = useState(false);
            
            // Firebase status
            const [firebaseStatus, setFirebaseStatus] = useState(
                isFirebaseConfigured ? 'connecting' : 'not_configured'
            );
            
            // Display constants
            const CANVAS_SIZE = 300;
            const DOT_RADIUS = 2;
            const DOT_SPEED = 3;
            const APERTURE_RADIUS = 120;
            
            // Refs
            const dotsRef = useRef([]);
            const directionRef = useRef(1);
            const animationRef = useRef(null);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIREBASE AUTHENTICATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            useEffect(() => {
                if (!isFirebaseConfigured || !auth) {
                    setFirebaseStatus('not_configured');
                    return;
                }
                
                auth.signInAnonymously()
                    .then((result) => {
                        setParticipantId(result.user.uid);
                        setFirebaseStatus('connected');
                    })
                    .catch((error) => {
                        console.error("Auth error:", error);
                        setFirebaseStatus('error');
                    });
            }, []);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LOAD POPULATION DATA
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const loadPopulationData = async () => {
                if (!db || firebaseStatus !== 'connected') return;
                
                setIsLoadingPopulation(true);
                try {
                    const snapshot = await db.collection('dot_motion_results')
                        .where('coherence', '==', coherence)
                        .orderBy('timestamp', 'desc')
                        .limit(500)
                        .get();
                    
                    const data = snapshot.docs.map(doc => doc.data());
                    setPopulationData(data);
                } catch (error) {
                    console.error("Error loading population data:", error);
                }
                setIsLoadingPopulation(false);
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SAVE RESULTS TO FIREBASE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const saveResults = async (accuracy, meanRT, correctRT) => {
                if (!db || firebaseStatus !== 'connected') return;
                
                try {
                    await db.collection('dot_motion_results').add({
                        participantId,
                        participantName: participantName || 'Anonymous',
                        coherence,
                        stimulusDuration,
                        numDots,
                        accuracy,
                        meanRT,
                        correctRT,
                        totalTrials,
                        trials,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        userAgent: navigator.userAgent
                    });
                    setDataSaved(true);
                    // Reload population data to include this result
                    await loadPopulationData();
                } catch (error) {
                    console.error("Error saving results:", error);
                }
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DOT MOTION LOGIC
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const initializeDots = useCallback(() => {
                const dots = [];
                for (let i = 0; i < numDots; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * APERTURE_RADIUS;
                    dots.push({
                        x: CANVAS_SIZE/2 + Math.cos(angle) * r,
                        y: CANVAS_SIZE/2 + Math.sin(angle) * r,
                        isSignal: Math.random() < coherence
                    });
                }
                dotsRef.current = dots;
            }, [numDots, coherence]);

            const updateDots = useCallback(() => {
                dotsRef.current = dotsRef.current.map(dot => {
                    let newX, newY;
                    
                    if (dot.isSignal) {
                        newX = dot.x + DOT_SPEED * directionRef.current;
                        newY = dot.y;
                    } else {
                        const randomAngle = Math.random() * Math.PI * 2;
                        newX = dot.x + Math.cos(randomAngle) * DOT_SPEED;
                        newY = dot.y + Math.sin(randomAngle) * DOT_SPEED;
                    }
                    
                    const dx = newX - CANVAS_SIZE/2;
                    const dy = newY - CANVAS_SIZE/2;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist > APERTURE_RADIUS) {
                        const angle = Math.atan2(dy, dx) + Math.PI;
                        newX = CANVAS_SIZE/2 + Math.cos(angle) * APERTURE_RADIUS * 0.9;
                        newY = CANVAS_SIZE/2 + Math.sin(angle) * APERTURE_RADIUS * 0.9;
                    }
                    
                    return { ...dot, x: newX, y: newY };
                });
            }, []);

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                
                ctx.strokeStyle = '#4a4a6a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(CANVAS_SIZE/2, CANVAS_SIZE/2, APERTURE_RADIUS, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(CANVAS_SIZE/2 - 10, CANVAS_SIZE/2);
                ctx.lineTo(CANVAS_SIZE/2 + 10, CANVAS_SIZE/2);
                ctx.moveTo(CANVAS_SIZE/2, CANVAS_SIZE/2 - 10);
                ctx.lineTo(CANVAS_SIZE/2, CANVAS_SIZE/2 + 10);
                ctx.stroke();
                
                if (gameState === 'stimulus') {
                    ctx.fillStyle = '#ffffff';
                    dotsRef.current.forEach(dot => {
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            }, [gameState]);

            useEffect(() => {
                if (gameState === 'stimulus') {
                    const animate = () => {
                        updateDots();
                        draw();
                        animationRef.current = requestAnimationFrame(animate);
                    };
                    animate();
                    
                    return () => {
                        if (animationRef.current) {
                            cancelAnimationFrame(animationRef.current);
                        }
                    };
                } else {
                    draw();
                }
            }, [gameState, draw, updateDots]);

            const startTrial = useCallback(() => {
                directionRef.current = Math.random() < 0.5 ? -1 : 1;
                initializeDots();
                setGameState('stimulus');
                setStimulusStartTime(Date.now());
                
                setTimeout(() => {
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                    setGameState('ready');
                }, stimulusDuration);
            }, [initializeDots, stimulusDuration]);

            const handleResponse = useCallback((response) => {
                if (gameState !== 'stimulus' && gameState !== 'ready') return;
                if (stimulusStartTime === null) return;
                
                const rt = Date.now() - stimulusStartTime;
                const correct = (response === 'left' && directionRef.current === -1) || 
                               (response === 'right' && directionRef.current === 1);
                
                const trialData = {
                    trialNum: trialCount + 1,
                    direction: directionRef.current === 1 ? 'right' : 'left',
                    response,
                    correct,
                    rt,
                    coherence
                };
                
                setTrials(prev => [...prev, trialData]);
                setFeedback(correct ? 'Correct!' : 'Incorrect');
                setGameState('feedback');
                
                setTimeout(() => {
                    if (trialCount + 1 >= totalTrials) {
                        setGameState('results');
                    } else {
                        setTrialCount(prev => prev + 1);
                        setFeedback(null);
                        setGameState('ready');
                    }
                }, 800);
            }, [gameState, stimulusStartTime, trialCount, totalTrials, coherence]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowLeft') {
                        handleResponse('left');
                    } else if (e.key === 'ArrowRight') {
                        handleResponse('right');
                    } else if (e.key === ' ' && gameState === 'ready') {
                        e.preventDefault();
                        startTrial();
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleResponse, startTrial, gameState]);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RESULTS CALCULATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const getResults = useCallback(() => {
                if (trials.length === 0) return { accuracy: 0, meanRT: 0, correctRT: 0 };
                const accuracy = trials.filter(t => t.correct).length / trials.length;
                const meanRT = trials.reduce((sum, t) => sum + t.rt, 0) / trials.length;
                const correctTrials = trials.filter(t => t.correct);
                const correctRT = correctTrials.length > 0 
                    ? correctTrials.reduce((sum, t) => sum + t.rt, 0) / correctTrials.length 
                    : 0;
                return { accuracy, meanRT, correctRT };
            }, [trials]);

            // Save and load when reaching results
            useEffect(() => {
                if (gameState === 'results' && !dataSaved) {
                    const { accuracy, meanRT, correctRT } = getResults();
                    saveResults(accuracy, meanRT, correctRT);
                    loadPopulationData();
                }
            }, [gameState, dataSaved, getResults]);

            const resetGame = () => {
                setTrials([]);
                setTrialCount(0);
                setFeedback(null);
                setDataSaved(false);
                setGameState('intro');
            };

            // Population statistics
            const populationAccuracies = populationData.map(d => d.accuracy * 100);
            const populationRTs = populationData.filter(d => d.correctRT > 0).map(d => d.correctRT);
            const myResults = getResults();

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RENDER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            return (
                <div className="min-h-screen bg-slate-900 text-white p-6">
                    <div className="max-w-3xl mx-auto">
                        <h1 className="text-2xl font-bold text-center mb-2">
                            Random Dot Motion Task
                        </h1>
                        <p className="text-slate-400 text-center text-sm mb-2">
                            A classic perceptual decision-making paradigm
                        </p>
                        
                        {/* Firebase Status */}
                        <div className="text-center mb-4">
                            {firebaseStatus === 'connected' && (
                                <span className="text-xs bg-green-900 text-green-300 px-2 py-1 rounded">
                                    â— Data saving enabled
                                </span>
                            )}
                            {firebaseStatus === 'not_configured' && (
                                <span className="text-xs bg-yellow-900 text-yellow-300 px-2 py-1 rounded">
                                    â—‹ Demo mode (data not saved)
                                </span>
                            )}
                            {firebaseStatus === 'error' && (
                                <span className="text-xs bg-red-900 text-red-300 px-2 py-1 rounded">
                                    âœ• Connection error
                                </span>
                            )}
                        </div>

                        {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
                        {/* INTRO SCREEN                                            */}
                        {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
                        {gameState === 'intro' && (
                            <div className="bg-slate-800 rounded-lg p-6 mb-6">
                                <h2 className="text-lg font-semibold mb-4">Instructions</h2>
                                <p className="text-slate-300 mb-4">
                                    You'll see a cloud of moving dots. Some dots move coherently 
                                    LEFT or RIGHT, while others move randomly. Your job is to 
                                    decide which direction the coherent dots are moving.
                                </p>
                                <ul className="text-slate-300 space-y-2 mb-6">
                                    <li>â€¢ Press <span className="bg-slate-700 px-2 py-1 rounded font-mono">SPACE</span> to start each trial</li>
                                    <li>â€¢ Press <span className="bg-slate-700 px-2 py-1 rounded font-mono">â†</span> for LEFT or <span className="bg-slate-700 px-2 py-1 rounded font-mono">â†’</span> for RIGHT</li>
                                    <li>â€¢ Respond as quickly and accurately as possible</li>
                                </ul>
                                
                                {/* Name input */}
                                {firebaseStatus === 'connected' && (
                                    <div className="mb-4">
                                        <label className="block text-sm text-slate-400 mb-1">
                                            Your name (optional, for leaderboard):
                                        </label>
                                        <input
                                            type="text"
                                            value={participantName}
                                            onChange={(e) => setParticipantName(e.target.value)}
                                            placeholder="Anonymous"
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white placeholder-slate-500"
                                        />
                                    </div>
                                )}
                                
                                <div className="border-t border-slate-700 pt-4 mt-4">
                                    <h3 className="text-sm font-semibold text-slate-400 mb-3">
                                        PARAMETERS
                                    </h3>
                                    <div className="grid grid-cols-1 gap-4">
                                        <div>
                                            <label className="block text-sm text-slate-400 mb-1">
                                                Coherence: {(coherence * 100).toFixed(0)}%
                                            </label>
                                            <input
                                                type="range"
                                                min="0.05"
                                                max="0.8"
                                                step="0.05"
                                                value={coherence}
                                                onChange={(e) => setCoherence(parseFloat(e.target.value))}
                                                className="w-full accent-blue-500"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm text-slate-400 mb-1">
                                                Stimulus Duration: {stimulusDuration}ms
                                            </label>
                                            <input
                                                type="range"
                                                min="200"
                                                max="2000"
                                                step="100"
                                                value={stimulusDuration}
                                                onChange={(e) => setStimulusDuration(parseInt(e.target.value))}
                                                className="w-full accent-blue-500"
                                            />
                                        </div>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={() => setGameState('ready')}
                                    className="w-full mt-6 bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-semibold transition"
                                >
                                    Start Experiment
                                </button>
                            </div>
                        )}

                        {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
                        {/* TRIAL SCREEN                                            */}
                        {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
                        {(gameState === 'ready' || gameState === 'stimulus' || gameState === 'feedback') && (
                            <div className="flex flex-col items-center">
                                <div className="mb-4 text-sm text-slate-400">
                                    Trial {trialCount + 1} of {totalTrials} | Coherence: {(coherence * 100).toFixed(0)}%
                                </div>
                                
                                <canvas
                                    ref={canvasRef}
                                    width={CANVAS_SIZE}
                                    height={CANVAS_SIZE}
                                    className="rounded-lg mb-4"
                                />
                                
                                {gameState === 'ready' && !feedback && (
                                    <p className="text-slate-400 mb-4">Press SPACE to start trial</p>
                                )}
                                
                                {feedback && (
                                    <p className={`text-lg font-bold mb-4 ${
                                        feedback === 'Correct!' ? 'text-green-400' : 'text-red-400'
                                    }`}>
                                        {feedback}
                                    </p>
                                )}
                                
                                <div className="flex gap-4">
                                    <button
                                        onClick={() => handleResponse('left')}
                                        className="bg-slate-700 hover:bg-slate-600 px-8 py-3 rounded-lg font-semibold transition"
                                    >
                                        â† LEFT
                                    </button>
                                    <button
                                        onClick={() => handleResponse('right')}
                                        className="bg-slate-700 hover:bg-slate-600 px-8 py-3 rounded-lg font-semibold transition"
                                    >
                                        RIGHT â†’
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
                        {/* RESULTS SCREEN                                          */}
                        {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
                        {gameState === 'results' && (
                            <div className="bg-slate-800 rounded-lg p-6">
                                <h2 className="text-xl font-bold mb-4 text-center">Your Results</h2>
                                
                                {/* Your scores */}
                                <div className="grid grid-cols-3 gap-4 mb-6">
                                    <div className="bg-slate-700 rounded-lg p-4 text-center">
                                        <div className="text-3xl font-bold text-blue-400">
                                            {(myResults.accuracy * 100).toFixed(0)}%
                                        </div>
                                        <div className="text-sm text-slate-400">Accuracy</div>
                                    </div>
                                    <div className="bg-slate-700 rounded-lg p-4 text-center">
                                        <div className="text-3xl font-bold text-green-400">
                                            {myResults.correctRT.toFixed(0)}ms
                                        </div>
                                        <div className="text-sm text-slate-400">Correct RT</div>
                                    </div>
                                    <div className="bg-slate-700 rounded-lg p-4 text-center">
                                        <div className="text-3xl font-bold text-yellow-400">
                                            {(coherence * 100).toFixed(0)}%
                                        </div>
                                        <div className="text-sm text-slate-400">Coherence</div>
                                    </div>
                                </div>

                                {/* Population Comparison */}
                                {populationData.length > 1 && (
                                    <div className="mb-6">
                                        <h3 className="text-lg font-semibold mb-4 text-center">
                                            ğŸ“Š How You Compare (n={populationData.length})
                                        </h3>
                                        
                                        {/* Percentile badges */}
                                        <div className="grid grid-cols-2 gap-4 mb-4">
                                            <div className="bg-slate-900 rounded-lg p-3 text-center">
                                                <div className="text-2xl font-bold text-blue-400">
                                                    {calculatePercentile(myResults.accuracy * 100, populationAccuracies)}th
                                                </div>
                                                <div className="text-xs text-slate-400">Accuracy Percentile</div>
                                            </div>
                                            <div className="bg-slate-900 rounded-lg p-3 text-center">
                                                <div className="text-2xl font-bold text-green-400">
                                                    {100 - calculatePercentile(myResults.correctRT, populationRTs)}th
                                                </div>
                                                <div className="text-xs text-slate-400">Speed Percentile</div>
                                                <div className="text-xs text-slate-500">(faster = higher)</div>
                                            </div>
                                        </div>
                                        
                                        {/* Histograms */}
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div className="bg-slate-900 rounded-lg p-3">
                                                <Histogram 
                                                    data={populationAccuracies}
                                                    userValue={myResults.accuracy * 100}
                                                    label="Accuracy Distribution (%)"
                                                    color="rgba(59, 130, 246, 0.6)"
                                                    unit="%"
                                                />
                                                <div className="text-center text-xs text-amber-400 mt-2">
                                                    â–  Your score highlighted in orange
                                                </div>
                                            </div>
                                            <div className="bg-slate-900 rounded-lg p-3">
                                                <Histogram 
                                                    data={populationRTs}
                                                    userValue={myResults.correctRT}
                                                    label="Reaction Time Distribution (ms)"
                                                    color="rgba(34, 197, 94, 0.6)"
                                                    unit="ms"
                                                />
                                                <div className="text-center text-xs text-amber-400 mt-2">
                                                    â–  Your score highlighted in orange
                                                </div>
                                            </div>
                                        </div>
                                        
                                        {/* Population stats */}
                                        <div className="mt-4 text-center text-sm text-slate-400">
                                            Population avg: {(populationAccuracies.reduce((a,b) => a+b, 0) / populationAccuracies.length).toFixed(0)}% accuracy, {" "}
                                            {(populationRTs.reduce((a,b) => a+b, 0) / populationRTs.length).toFixed(0)}ms RT
                                        </div>
                                    </div>
                                )}
                                
                                {populationData.length <= 1 && firebaseStatus === 'connected' && (
                                    <div className="bg-slate-900 rounded-lg p-4 mb-6 text-center">
                                        <p className="text-slate-400">
                                            {isLoadingPopulation ? (
                                                "Loading population data..."
                                            ) : (
                                                "You're among the first! Population comparison will appear as more people complete the task."
                                            )}
                                        </p>
                                    </div>
                                )}
                                
                                {/* Trial data */}
                                <div className="bg-slate-700 rounded-lg p-4 mb-6">
                                    <h3 className="font-semibold mb-2">Trial-by-Trial Data</h3>
                                    <div className="text-xs font-mono text-slate-400 max-h-32 overflow-y-auto">
                                        <div className="grid grid-cols-5 gap-2 mb-1 text-slate-500 border-b border-slate-600 pb-1">
                                            <span>Trial</span>
                                            <span>Dir</span>
                                            <span>Resp</span>
                                            <span>Correct</span>
                                            <span>RT</span>
                                        </div>
                                        {trials.map((t, i) => (
                                            <div key={i} className="grid grid-cols-5 gap-2 py-0.5">
                                                <span>{t.trialNum}</span>
                                                <span>{t.direction}</span>
                                                <span>{t.response}</span>
                                                <span className={t.correct ? 'text-green-400' : 'text-red-400'}>
                                                    {t.correct ? 'âœ“' : 'âœ—'}
                                                </span>
                                                <span>{t.rt}ms</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                
                                {/* Data saved indicator */}
                                {dataSaved && (
                                    <div className="text-center text-sm text-green-400 mb-4">
                                        âœ“ Your results have been saved
                                    </div>
                                )}
                                
                                <button
                                    onClick={resetGame}
                                    className="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-semibold transition"
                                >
                                    Try Again
                                </button>
                            </div>
                        )}

                        {/* Footer */}
                        <div className="mt-8 text-center text-xs text-slate-500">
                            <p>Based on the random dot kinematogram paradigm</p>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DotMotionTask />);
    </script>
</body>
</html>
